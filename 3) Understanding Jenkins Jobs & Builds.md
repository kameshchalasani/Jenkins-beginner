# **🔧 Understanding Jenkins Jobs & Builds** 🚀  

Jenkins automates software development through **jobs** and **builds**, allowing teams to implement Continuous Integration (CI) and Continuous Deployment (CD). This guide covers:  
✅ **Jenkins Jobs & Build Concepts**  
✅ **Freestyle vs. Pipeline Jobs**  
✅ **Build Triggers (Manual, SCM Polling, Webhooks)**  
✅ **Build Parameters & Environment Variables**  
✅ **Managing Build History & Artifacts**  
✅ **Integrating Jenkins with Git (GitHub, GitLab, Bitbucket)**  

---

## **1️⃣ Understanding Jenkins Jobs & Builds**
### **🔹 What is a Job in Jenkins?**
A **Jenkins Job** (also called a Project) is a **set of tasks** that automate:
- **Building** code (e.g., compiling Java, Node.js, Python projects)
- **Testing** code (e.g., running unit & integration tests)
- **Deploying** applications (e.g., pushing code to a production server)

### **🔹 What is a Build in Jenkins?**
A **Build** is a single execution of a Jenkins Job. Every time a job runs, Jenkins:  
✔ Checks out code from the repository  
✔ Runs build commands  
✔ Executes tests  
✔ Generates artifacts  
✔ Deploys applications (if configured)  

---

## **2️⃣ Freestyle Jobs vs. Pipeline Jobs**
### **🔹 Freestyle Jobs**
- **Simple & GUI-based**
- Best for **basic automation tasks**
- Supports **manual & SCM-triggered builds**
- **Limited flexibility** (not ideal for complex workflows)

🔹 **Example:**
- Pull code from **Git**
- Run a **shell script**
- Archive artifacts

---

### **🔹 Pipeline Jobs**
- **Scripted (Jenkinsfile-based) & highly flexible**
- Uses **Groovy-based syntax**
- Supports **CI/CD workflows, parallel execution, & complex dependencies**
- Ideal for **Docker, Kubernetes, AWS deployments**

🔹 **Example:**
```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'mvn clean package'
            }
        }
        stage('Test') {
            steps {
                sh 'mvn test'
            }
        }
        stage('Deploy') {
            steps {
                sh 'scp target/*.war user@server:/deployments'
            }
        }
    }
}
```
✅ **Use Freestyle Jobs for basic tasks**  
✅ **Use Pipeline Jobs for full CI/CD automation**

---

## **3️⃣ Configuring Build Triggers**
### **🔹 Manual Trigger**
- **Run a job manually** via the Jenkins UI  
- Click **"Build Now"**  

---

### **🔹 SCM Polling (Scheduled Trigger)**
- Jenkins checks the Git repository at intervals  
- Example (poll every 5 mins):  
  ```
  H/5 * * * *
  ```
🔹 **Steps to Enable:**
1️⃣ Open **Jenkins Job → Configure**  
2️⃣ Scroll to **"Build Triggers"**  
3️⃣ Check **"Poll SCM"**  
4️⃣ Enter schedule (e.g., `H/5 * * * *`)  
5️⃣ Save & Apply  

---

### **🔹 Webhooks (Auto-trigger on Git Push)**
🔹 **Webhooks trigger Jenkins immediately when code is pushed to GitHub/GitLab**  

#### **GitHub Webhook Setup**
1️⃣ In GitHub, go to **Repository Settings → Webhooks**  
2️⃣ Click **"Add Webhook"**  
3️⃣ Enter Jenkins URL:  
   ```
   http://JENKINS_SERVER:8080/github-webhook/
   ```
4️⃣ Select **"Push Event"**  
5️⃣ Click **Save**  

🔹 **Now, every push will trigger a Jenkins build!** 🚀

---

## **4️⃣ Build Parameters & Environment Variables**
### **🔹 What are Build Parameters?**
- Allow **dynamic inputs** for Jenkins Jobs  
- Useful for **deploying to different environments (Dev, Staging, Production)**  

🔹 **Steps to Add Parameters:**
1️⃣ Open **Jenkins Job → Configure**  
2️⃣ Check **"This project is parameterized"**  
3️⃣ Click **"Add Parameter"** and choose:  
   - **String Parameter** (e.g., `APP_ENV=production`)  
   - **Choice Parameter** (e.g., Dev, Staging, Prod)  
   - **Boolean Parameter** (true/false)  

🔹 **Example: Using Parameters in a Shell Script**
```sh
echo "Deploying to Environment: $APP_ENV"
if [ "$APP_ENV" == "production" ]; then
    echo "Deploying to Prod Server..."
fi
```

---

### **🔹 Jenkins Environment Variables**
Jenkins provides built-in environment variables for builds.

| Variable | Description |
|----------|------------|
| `BUILD_NUMBER` | Current build number |
| `JOB_NAME` | Name of the Jenkins job |
| `WORKSPACE` | Directory where the job runs |
| `GIT_COMMIT` | Latest Git commit hash |
| `GIT_BRANCH` | Current Git branch |

🔹 **Example: Using Env Variables in Shell Script**
```sh
echo "Building Project: $JOB_NAME"
echo "Git Commit: $GIT_COMMIT"
```

---

## **5️⃣ Managing Build History & Artifacts**
### **🔹 Build History**
- View previous builds in **Jenkins Dashboard → Job → Build History**  
- Click on a build to see **logs & results**  

### **🔹 Archiving Build Artifacts**
Artifacts are files generated by the build (e.g., `.war`, `.jar`, `.zip`).  

🔹 **Steps to Archive Artifacts:**
1️⃣ Open **Jenkins Job → Configure**  
2️⃣ Scroll to **Post-Build Actions**  
3️⃣ Click **"Archive the Artifacts"**  
4️⃣ Enter files to archive (e.g., `target/*.war`)  
5️⃣ Save & Apply  

📌 **Artifacts will now be stored in Jenkins for future downloads!**  

---

## **6️⃣ Integrating Jenkins with Git (GitHub, GitLab, Bitbucket)**
### **🔹 Steps to Integrate GitHub with Jenkins**
1️⃣ Install **Git Plugin** (Manage Jenkins → Plugins → Install Git Plugin)  
2️⃣ Go to **Jenkins Job → Configure**  
3️⃣ In **Source Code Management**, select **Git**  
4️⃣ Enter **GitHub Repository URL**  
5️⃣ Add credentials (if needed)  
6️⃣ Save & Apply  

🔹 **Example: Git Checkout in Freestyle Job**
```sh
git clone https://github.com/user/repo.git
cd repo
git checkout develop
```

---

## **🎯 Summary**
✔ **Freestyle Jobs** are GUI-based, **Pipeline Jobs** are script-based  
✔ **Triggers**: Manual, SCM Polling, Webhooks (for Git push events)  
✔ **Build Parameters** allow dynamic input for jobs  
✔ **Jenkins Environment Variables** provide useful build metadata  
✔ **Archived Artifacts** store important build outputs  
✔ **GitHub/GitLab/Bitbucket** integration allows Jenkins to fetch code automatically  
